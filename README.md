# Домашнее задание к занятию "Работа в терминале. Лекция 2"

1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.
   
cd - внутренняя команда bash. Выполняется без порождения дочернего процесса (fork). Изменяет директорию в рамках оболочки bash. 
Если запустить команду как внешнюю она породит дочерний процесс, поменяет рабочий каталог в рамках дочернего процесса через системный вызов chdir, но каталог родительского процесса - оболочки, не изменит.

2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

grep -c <some_string> <some_file>

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Система инициализации systemmd в Ubuntu
Для примера на Mac это launchd

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
ls strange_dir 2>/dev/pts/1

5. Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.
Если нужно записать содержимое файла file1 в file2 можно использовать команду
cat < file1 > file2

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да. Например, поменять местами STDOUT и STDERR. Для этого применяется конструкция desc>&1 1>&2 2>&desc  

7. Выполните команду bash 5>&1. К чему она приведёт? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Команда bash 5>&1 создаст файловый дескриптор 5 и перенаправит его в в стандартный вывод.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?
Напоминаем: по умолчанию через pipe передаётся только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Да, получится ls -123 3>&2 2>&1 1>&3 | wc -l

9. Что выведет команда cat /proc/$$/environ? Как ещё можно получить аналогичный по содержанию вывод?

Выведет переменные окружения текущего процесса, формат **имя_переменной=значение**. Можно использовать команду env - она выводет список всех переменных окружения текущей оболочки, формат аналогичный.

Еще есть команда printenv, которая работает аналогично команде env, но выводит только значения переменных окружения, указанных в аргументах командной строки.

10. Используя man, опишите, что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe

**/proc/<PID>/cmdline** - read-only файл, командная строка для процесса, если последний не является зомби. Если процесс зомби, тогда при чтении вернется 0

**/proc/<PID>/exe** - символическая ссылка, содержащая путь к исполняемой команде. При попытке открыть файл будет запущена копия процесса

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo

sse 4_2

12. При открытии нового окна терминала и vagrant ssh создаётся новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.

При подключении по ssh tty сеанс по умолчанию не выделяется, когда же из shell запускается ssh, то первым запускается shell и в таком случае tty выделяется, однако ssh ждет передачу user, а в данной команде его нет. 

ssh -t localhost 'tty' -t принудительное открытие псевдотерминала.

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Для этого устанавливаем значение kernel.yama.ptrace_scope = 0

14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell, который запущен без sudo под вашим пользователем. Для решения этой проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте, что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

tee - читает из stdin и пишет stdout и файл. если tee запускается отдельным процессом под sudo, то получая в stdin через pipe данные от echo она имеет права записи в файл.